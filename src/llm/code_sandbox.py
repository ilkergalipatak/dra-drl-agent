"""
Code Sandbox for Safe Execution of LLM-Generated Code

Provides isolated execution environment for running operator code
generated by the LLM, with timeout and safety checks.
"""

import numpy as np
from typing import Callable, Optional, Dict, Any, Tuple
import traceback
import signal
import sys


class TimeoutError(Exception):
    """Raised when code execution times out."""

    pass


class CodeSandbox:
    """
    Safe execution environment for LLM-generated operator code.

    Features:
    - Syntax validation
    - Restricted execution environment
    - Timeout protection
    - Output validation
    """

    # Allowed modules in the sandbox
    ALLOWED_MODULES = {"numpy", "np", "math"}

    # Forbidden patterns in code
    FORBIDDEN_PATTERNS = [
        "import os",
        "import sys",
        "import subprocess",
        "__import__",
        "eval(",
        "exec(",
        "open(",
        "file(",
        "input(",
        "compile(",
        "globals(",
        "locals(",
        "getattr(",
        "setattr(",
        "delattr(",
        "breakpoint(",
        "__builtins__",
        "socket",
        "urllib",
        "requests",
        "shutil",
        "pickle",
        "marshal",
    ]

    def __init__(self, timeout: int = 5):
        """
        Initialize sandbox.

        Args:
            timeout: Maximum execution time in seconds
        """
        self.timeout = timeout
        self._execution_count = 0
        self._success_count = 0
        self._failure_count = 0

    def _check_code_safety(self, code: str) -> Tuple[bool, str]:
        """
        Check if code is safe to execute.

        Returns:
            Tuple of (is_safe, error_message)
        """
        for pattern in self.FORBIDDEN_PATTERNS:
            if pattern in code:
                return False, f"Forbidden pattern found: {pattern}"

        return True, ""

    def _extract_function(self, code: str) -> str:
        """
        Extract Python function from LLM response.

        Handles markdown code blocks and raw code.
        """
        # Remove markdown code blocks
        if "```python" in code:
            start = code.find("```python") + 9
            end = code.find("```", start)
            if end > start:
                code = code[start:end]
        elif "```" in code:
            start = code.find("```") + 3
            end = code.find("```", start)
            if end > start:
                code = code[start:end]

        # Strip whitespace
        code = code.strip()

        return code

    def _create_safe_globals(self) -> Dict[str, Any]:
        """Create restricted globals for execution."""
        safe_globals = {
            "np": np,
            "numpy": np,
            "abs": abs,
            "min": min,
            "max": max,
            "sum": sum,
            "len": len,
            "range": range,
            "enumerate": enumerate,
            "zip": zip,
            "map": map,
            "filter": filter,
            "round": round,
            "int": int,
            "float": float,
            "bool": bool,
            "list": list,
            "tuple": tuple,
            "dict": dict,
            "set": set,
            "__builtins__": {},  # Restrict builtins
        }
        return safe_globals

    def compile_operator(self, code: str) -> Tuple[Optional[Callable], str]:
        """
        Compile LLM-generated code into a callable operator.

        Args:
            code: Python code string from LLM

        Returns:
            Tuple of (callable_function, error_message)
            If successful, error_message is empty.
        """
        self._execution_count += 1

        # Extract and clean code
        code = self._extract_function(code)

        # Safety check
        is_safe, error = self._check_code_safety(code)
        if not is_safe:
            self._failure_count += 1
            return None, error

        # Compile code
        try:
            compiled = compile(code, "<llm_operator>", "exec")
        except SyntaxError as e:
            self._failure_count += 1
            return None, f"Syntax error: {e}"

        # Execute to define function
        safe_globals = self._create_safe_globals()
        safe_locals = {}

        try:
            exec(compiled, safe_globals, safe_locals)
        except Exception as e:
            self._failure_count += 1
            return None, f"Execution error: {e}"

        # Extract the custom_operator function
        if "custom_operator" not in safe_locals:
            self._failure_count += 1
            return None, "Function 'custom_operator' not found in code"

        operator = safe_locals["custom_operator"]

        if not callable(operator):
            self._failure_count += 1
            return None, "'custom_operator' is not callable"

        self._success_count += 1
        return operator, ""

    def test_operator(self, operator: Callable, dim: int = 30) -> Tuple[bool, str]:
        """
        Test an operator with sample inputs.

        Args:
            operator: The operator function to test
            dim: Dimension for test vectors

        Returns:
            Tuple of (success, error_message)
        """
        try:
            # Create test inputs
            position = np.random.randn(dim)
            leader = np.random.randn(dim)
            iteration = 50
            max_iteration = 100

            # Run operator
            result = operator(position, leader, iteration, max_iteration)

            # Validate output
            if not isinstance(result, np.ndarray):
                return False, f"Output is not ndarray: {type(result)}"

            if result.shape != position.shape:
                return (
                    False,
                    f"Output shape mismatch: {result.shape} vs {position.shape}",
                )

            if not np.isfinite(result).all():
                return False, "Output contains NaN or Inf values"

            return True, ""

        except Exception as e:
            return False, f"Test failed: {e}\n{traceback.format_exc()}"

    def compile_and_test(
        self, code: str, dim: int = 30
    ) -> Tuple[Optional[Callable], bool, str]:
        """
        Compile and test operator in one step.

        Args:
            code: Python code from LLM
            dim: Dimension for testing

        Returns:
            Tuple of (operator, success, error_message)
        """
        operator, error = self.compile_operator(code)

        if operator is None:
            return None, False, error

        success, test_error = self.test_operator(operator, dim)

        if not success:
            return None, False, test_error

        return operator, True, ""

    def get_stats(self) -> Dict[str, Any]:
        """Get sandbox execution statistics."""
        return {
            "total_executions": self._execution_count,
            "successful": self._success_count,
            "failed": self._failure_count,
            "success_rate": self._success_count / max(1, self._execution_count),
        }


def create_fallback_operator(operator_type: str = "mutation") -> Callable:
    """
    Create a fallback operator when LLM generation fails.

    Args:
        operator_type: Type of operator to create

    Returns:
        A simple but effective operator function
    """
    if operator_type == "mutation":

        def fallback_mutation(position, leader, iteration, max_iteration):
            progress = iteration / max_iteration
            noise = np.random.randn(*position.shape) * (1 - progress)
            return position + noise

        return fallback_mutation

    elif operator_type == "crossover":

        def fallback_crossover(position, leader, iteration, max_iteration):
            alpha = np.random.random()
            return alpha * position + (1 - alpha) * leader

        return fallback_crossover

    elif operator_type == "local_search":

        def fallback_local_search(position, leader, iteration, max_iteration):
            progress = iteration / max_iteration
            step = 0.1 * (1 - progress)
            direction = leader - position
            return position + step * direction

        return fallback_local_search

    else:  # diversification

        def fallback_diversification(position, leader, iteration, max_iteration):
            # Opposition-based
            return -position + np.random.randn(*position.shape) * 0.1

        return fallback_diversification
